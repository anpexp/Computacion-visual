# -*- coding: utf-8 -*-
"""Transformación.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10ENY6zR2s0ZZSmTGL8zmnLFInoWZq51X
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
import imageio


num_frames = 60
images = []

# Definir el cuadrado original centrado en (0,0)
original_points = np.array([
    [-0.5, -0.5],
    [0.5, -0.5],
    [0.5, 0.5],
    [-0.5, 0.5],
    [-0.5, -0.5]  # Cerrar el cuadrado
])

# Convertir a coordenadas homogéneas (cada punto es una fila [x, y, 1])
points = np.hstack([original_points, np.ones((original_points.shape[0], 1))])

# Configuración de la animación
num_frames = 60
images = []

for frame in range(num_frames):
    t = frame / (num_frames - 1)  # t varía de 0 a 1

    # Calcular parámetros de transformación
    tx = 5 * t      # Desplazamiento en X
    ty = 3 * t      # Desplazamiento en Y
    theta = 2 * np.pi * t  # Rotación de 360 grados
    sx = 1 + 2 * t  # Escala de 1 a 3
    sy = 1 + 2 * t

    # Matriz de traslación
    T_translate = np.array([
        [1, 0, tx],
        [0, 1, ty],
        [0, 0, 1]
    ])

    # Matriz de rotación
    T_rotate = np.array([
        [np.cos(theta), -np.sin(theta), 0],
        [np.sin(theta), np.cos(theta), 0],
        [0, 0, 1]
    ])

    # Matriz de escala
    T_scale = np.array([
        [sx, 0, 0],
        [0, sy, 0],
        [0, 0, 1]
    ])

    # Combinar transformaciones: escala -> rotación -> traslación
    T = T_translate @ T_rotate @ T_scale

    # Aplicar transformación a los puntos
    transformed_points = (T @ points.T).T

    # Extraer coordenadas x e y
    x = transformed_points[:, 0]
    y = transformed_points[:, 1]

       # Crear figura y canvas
    fig, ax = plt.subplots(figsize=(6, 4))
    ax.plot(x, y, 'b-', linewidth=2)
    ax.set_xlim(-1, 6)
    ax.set_ylim(-1, 4)
    ax.set_aspect('equal')
    ax.grid(True)

    # Renderizar y obtener píxeles
    canvas = FigureCanvas(fig)
    canvas.draw()

    # Convertir a array numpy (RGBA)
    image = np.array(canvas.buffer_rgba())
    images.append(image[..., :3])  # Descartar canal alpha (opcional)

    plt.close(fig)

# Exportar GIF
imageio.mimsave('transformacion.gif', images, duration=0.1)